前幾天介紹了OCP（開放/封閉原則）、DRY（不要重複你自己）、SRP（單一責任原則）三個原則，有沒有發現這些原則都有個相同點：就是讓軟體更好維護，使用起來更不容易用錯。今天要介紹的也是有相同的味道，Liskov替換原則（LSP）。
  
這個原則不向前面三個一樣，可以聯想到這個原則是在做什麼的。其實我也不知道Liskov是誰啊~不過這個原則主要要表達的也是責任分類歸屬。
  
Liskov替換原則的定義是：<font color="blue">『子類別必須能夠替代基礎類別』</font>
  
也就是說不要繼承不必要的遺產，沒用到而去繼承反而是種累贅甚至會搞壞了整個系統也不一定。
  
來看以下這個有趣的範例：
```c#
class 鳥類 {  
    public void 飛行() {  
        Console.WriteLine("飛呀飛喔~~");  
    }  
    public void 吃() {  
        Console.WriteLine("好吃好吃~~");  
    }  
}  
  
class 烏鴉 : 鳥類 { }  
  
class 鴕鳥 : 鳥類 {  
    public void 飛行(){  
        throw new NotSupportedException();  
    }  
}  
```
  
結果當我執行他時：
``` 執行結果
飛呀飛喔~~
飛呀飛喔~~
飛呀飛喔~~
好吃好吃~~
好吃好吃~~
好吃好吃~~
```
  
```c#
static void 讓鳥去飛吧(List<鳥類> 一群鳥) {  
    foreach (var 一隻鳥 in 一群鳥) {  
        一隻鳥.飛行();  
    }  
}  
  
static void Main(string[] args) {  
    List<鳥類> 一群鳥 = new List<鳥類>();  
    一群鳥.Add(new 烏鴉());  
    一群鳥.Add(new 鴕鳥());  
    一群鳥.Add(new 鳥類());  
    讓鳥去飛吧(一群鳥);  
}  
```
  
有發現嗎？不能飛的，現在能飛了，不能吃的，現在也能吃了！是不是很無言呢？那是因為子類別無法替代基礎類別的所早成的，也就是違反了Liskov替換原則。其實這種情況不應該用繼承的，應該把飛行跟吃拉出來用介面然後再讓不同的鳥類去實做。關於這點，下次在跟大家介紹吧！
